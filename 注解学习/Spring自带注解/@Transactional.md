#  介绍：
- 这个在跟数据库交互中的时候 当程序出错时 能确保数据库不会被更
#  使用方法：
- 可以使用在类上面， 这样就是说整个类都有这个功能
    - 缺点就是占内存太大
- 可以使用在method上， 这样就是只有该方法有这功能
 

 
# @Transactional的属性设置
- 只读： 设置只读， 只能查询， 不能修改添加删除
    - @Transactional(readOnly = true)
- 超时： 在设置超时时间之内没有完成， 抛出异常回滚
    - @Transactional(timeout = -1)        永不超时
    - @Transactional(timeout = 3)         设置超时时间为3秒
- 回滚策略： 设置哪些异常不会滚
    - 哪些回滚设置
        - @Transactional(rollBackFor = "")
        - @Transactional(rollBackForClassName = "")
    - 哪些不回滚设置
        - @Transactional(noRollBackFor = "")
        - @Transactional(noRollBackForClassName = "")

- 隔离级别： 读的问题
    - @Transactional(isolation = Isolation.DEFAULT)   使用数据库默认的隔离级别
    - 有更多的Isolation.<properties>
- 传播行为： 事务（Transaction）方法之间的调用， 事务如何使用
    - 什么是传播行为
        - 简单来说就是在service类中有a() 方法和b()方法， a()方法上有事务， b()方法上也有事务， 当a()方法在执行过程中调用了b()方法， 事务如何传递的？是应该合并到一个事务里？ 还是开启一个新的事务
    - 一共有七种传播行为
        - Required：支持当前事务， 如果不存在就新建一个（这也是默认的） 
            - 没有就新建， 有加入
            - Ex. 你同时下单两本书，注意 是同时Book A为100元， Book B为10元， 而你身上只有105元， 而这时候对于Require来说， 他们是在一个事物， 即整个交易结束后才算结束， 那么当你只有100的时候，你可以购买A， 但此时事务还么结束， 你又要购买B的时候， 因为钱不够 就报错了，此时就要出现回滚，也就是 就算第一次成功的购买了A， 也进行回滚，也不保留在数据库中
        - Supports：支持当前事务， 如果没有 则以非事务方式执行
            - 有就加入 没有就不管了
        - Mandatory： 必须运行在一个事务中， 如果当前没有事务正在发生， 抛出异常
            - 有就加入 没有就抛出异常
        - Requires_New： 开启一个新
            - Ex. 你同时下单两本书, 注意 是同时，Book A为100元， Book B为10元， 而你身上只有105元， 而这时候对于Require_New来说， 他们不是在一个事物， 即买到哪算到哪， 那么当你只有100的时候，你可以购买A, 当你成功的购买了A了以后, 你的事务就完成了, 当你购买B的时候, 已经是第二个事务了, 此时因为第一个事务完成了 你所更改的信息会在数据库中保存, 及时第二次事务报错了 你进行回滚了 也不会影响到第一个事务